# encoding: UTF-8
#
# Read XML generated by mysqldump for an epub5 client and import it into a
# jade database.
#
# Command to run to generate the XML:
#
#   mysqldump --opt -Q -t --allow-keywords --hex-blob --skip-extended-insert -c --skip-add-locks --skip-disable-keys --tz-utc --default-character-set=utf8 -X -r /var/tmp/export.xml
#
#
#
# Call the rake task: XMLDUMP=/path/to/export.xml rake jade:import:epub5
#
# Optionally call the rake task with a directory of *.xml files to import:
# XMLDUMP=/path/to/export/directory/  rake ibj:import:all

require 'nokogiri'

namespace :jade do
  namespace :import do
    desc "Read epub5 XML mysqldump and load into database"
    task :epub5 => [:environment, "db:migrate"] do
      # xmldump = ENV['XMLDUMP']
      # # support reading an entire directory of xmls
      # if File.directory?(xmldump)
      #   Dir.glob("#{ENV['XMLDUMP']}/**/*.xml").each do |filename|
      #     puts ">>>>>>> #{filename} >>>>>>>>>"
      #     Jade::Import::Epub5.import(filename)
      #   end
      # else
      #   Jade::Import::Epub5.import(xmldump)
      # end

      Jade::Import::Epub5.munge_taxonomies
    end
  end
end


# RAILS_ENV=local bundle exec rake ibj:import:create_subscriptions_from_quickfill_users
namespace :ibj do
  namespace :import do
    desc "Split EventAttendant#contact_person into first and last name"
    task update_event_attendant_contact: :environment do
      puts "Updating event attendants..."
      EventAttendant.find_each do |attendant|
        first, last = attendant.contact_person.to_s.split(/\s+/)
        attendant.contact_person_first = first
        attendant.contact_person_last  = last
        attendant.save(validate: false)
      end
      puts "done."
    end

    desc "Perform all imports"
    task :all => ["jade:import:epub5", "db:seed", :remap_taxonomy, :create_subscriptions_from_quickfill_users]

    desc "Performs required taxonomy remappings"
    task :remap_taxonomy => :environment do
      #Videos (remote) OLD SITE Classification > Multimedia > Video (50)  NEW SITE Topic / Category > Video Galleries > (child of Video Galleries) (Example General)
      Jade::Import::Epub5::move_taxonomies(50, Taxonomy.find_by_name("VIDEO_CATEGORIES"))
      # Photo Galleries (remote)  Classification > Multimedia > Photo Gallery (52)  NEW SITE Topic / Category > Photo Galleries > (child of Photo Galleries) (Example General)
      Jade::Import::Epub5::move_taxonomies(52, Taxonomy.find_by_name("PHOTO_CATEGORIES"))
      # Podcasts (remote) Classification > Multimedia > Podcasts (51)               NEW SITE Topic / Category > Audio Galleries > (child of Audio Galleries) (Example General)
      Jade::Import::Epub5::move_taxonomies(51, Taxonomy.find_by_name("AUDIO_CATEGORIES"))
      # IBJ Radio Classification > Multimedia > IBJ Radio (53)                      NEW SITE Topic / Category > Audio Galleries > (child of Audio Galleries) (IBJ Radio)
      Jade::Import::Epub5::move_taxonomies(53, Taxonomy.find_by_name("AUDIO_CATEGORIES"))
      # IBJ Events Videos Classification > Multimedia > IBJ Events (2412)           NEW SITE Topic / Category > Video Galleries > (child of Video Galleries) (IBJ Events)
      Jade::Import::Epub5::move_taxonomies(2412, Taxonomy.find_by_name("VIDEO_CATEGORIES"))
      # IBJ Events (calendar) Classification > Events > IBJ Events (1175) and all children            NEW SITE Topic / Category > Events (9) > IBJ Events and all children
      Jade::Import::Epub5::move_taxonomies(1175, Taxonomy.find_by_name("EVENT_CATEGORIES"))
      # Community Events (calendar  Classification > Events > Community Events (72) and all children  NEW SITE Topic / Category > Events (9) > Community Events and all children
      Jade::Import::Epub5::move_taxonomies(72, Taxonomy.find_by_name("EVENT_CATEGORIES"))
    end

    desc "Generates qfie resource subscriptions from the epub5 based quickfill_users"
    task :create_subscriptions_from_quickfill_users => :environment do
      ["DELETE FROM subscriptions WHERE resource LIKE 'QFIE'",
       "INSERT INTO subscriptions(start_date, resource, status, subscription_type, user_id, external_id)
           SELECT now(), 'QFIE', 'active', 'Site', user_id, cust_number FROM quickfill_users"].each do |stmt|
        ActiveRecord::Base.connection.execute stmt
      end
    end

    # This task imports shipping rates from a CSV file, which must be specdified
    # as the environment variable RATES_FILE.
    #
    # Example call: rake ibj:import:shipping_rates RATES_FILE=/path/to/rates.csv
    #
    # Each entry in the CSV file must have the form:
    #
    #   weight, rate
    #
    # where 'weight' is an integer and 'rate' a decimal number.
    #
    desc 'Imports shipping rate data'
    task shipping_rates: :environment do
      rates_file_path = ENV['RATES_FILE']
      Jade::Import::Epub6::ShippingRates.import(rates_file_path)
    end
  end
end

module Jade
  module Import
    module Epub5
      class << self

        def munge_taxonomies
          # Ensure TOPICS is present and under "Topic / Category"
          topics = Taxonomy.find_or_create_by_name('TOPICS') do |t|
            t.tree_path = ":1:"
            t.has_child = true
            t.title = "Topics"
            t.sorting_order = 2
            t.active = true
            t.selectable = true
          end

          # # ENSURE DIRECTORY_CATEGORIES is setup
          # set_taxonomy_name(176, "DIRECTORY_CATEGORIES")

          # # NO RIGHT_RAIL to become NO_SIDEBARS
          # Taxonomy.find_by_name('NO_SIDEBARS').update_attributes(name: nil) rescue nil
          # set_taxonomy_name(1533, "NO_SIDEBARS")

          # # title "Lists" to become  (THIS WEEKS LISTS)
          # set_taxonomy_name(86, "LISTS_CLASSIFICATIONS")
          # set_taxonomy_name(124, "DATAJOE_LIST")

          # # Site Placement > Blogs becomes BLOG_CATEGORIES
          # set_taxonomy_name(82, "BLOG_CATEGORIES")
          # # move under topic/categories
          # move_taxonomies(82, Taxonomy.find_by_name("TOPIC_CATEGORY"))

          # # Move the following taxonomies by id under TOPICS
          # [33, 1127, 128, 1103, 1223, 34, 82].each do |t|
          #   move_taxonomies(t, topics)
          # end

          # munge_taxonomies_2

          require_reg_and_sub_for_all_articles
        end

        def require_reg_and_sub_for_all_articles
          addx = [Taxonomy::REQUIRE_REGISTRATION, Taxonomy::REQUIRE_SUBSCRIPTION]
          Article.all.each do |article|
            article.taxonomies |= addx
          end
        end

        def munge_taxonomies_2
          Article.by_taxonomy(1584, 1585, 1806).each do |article|
            article.taxonomies |= [Taxonomy::FEATURED_STORIES]
          end

          # TODO: merge BREAKING_NEWS
          # move_taxonomies 561, Taxonomy::SITE_PLACEMENT
          # Taxonomy.find(561).update_attributes! name: 'BREAKING_NEWS'

          # TODO: merge SPECIAL_REPORTS
          # move_taxonomies 562, Taxonomy::SITE_PLACEMENT
          # Taxonomy.find(562).update_attributes! name: 'SPECIAL_REPORTS'
        end

        # Move the from_branch taxonomies under the to_branch taxonomies
        def move_taxonomies(tax_id, to_branch)
          t = TaxonomyAdmin.find(tax_id)
          if t
            t.move_branch_to(to_branch)
            t.save!
          end
        end

        def set_taxonomy_name(taxid, internal_name)
          t = Taxonomy.find(taxid)
          if t
            t.name = internal_name
            t.save!
          end
        end

        def import(filename)
          create_taxonomy_internal_name = Class.new do
            def call(record)
              return unless record.table == 'Taxonomy'

              # Create an InternalName by stripping non letters from the Title and capitalizing it
              if record.field("TreePath").data.empty?
                internal_name = "#{record.field('Title').data.upcase.gsub(/[^A-Z0-9 ]/, ' ').strip.gsub(/\s+/, '_')}"
              else
                internal_name = "_$#{record.field('TreePath').data}$_#{record.field('Title').data.upcase.gsub(/[^A-Z0-9 ]/, ' ').strip.gsub(/\s+/, '_')}"
              end
              internal_name = 'FREE_CLASSIFICATION' if internal_name == 'FREE'
              record.replace(Field.new('InternalName', internal_name))
            end
          end

          document = MysqlDumpDocument.new([
            ->(record) { raise StopIteration unless record.table =~ /^[A-Z]/ },
            ->(record) { record.remove("SortingOrder") if record.table =~ /^(Article|Product)(File|Video|Image)$/ },
            ->(record) { record.replace(Field.new("Created", Time.now.to_s)) if record.has?("Created") && record.field("Created").is_a?(NullField) },
            ->(record) { record.replace(Field.new("Address2", "")) if record.table =~ /Event/ && record.has?("Address2") && record.field("Address2").is_a?(NullField)},
            create_taxonomy_internal_name.new,
          ])

          parser = Nokogiri::XML::SAX::PushParser.new(document)

          ActiveRecord::Base.connection.disable_referential_integrity do
            File.open(filename, "r:UTF-8") do |xml|
              parser << read_from(xml) while !xml.eof?
            end

            parser.finish
          end
        end

        def read_from(xml)
          remove_invalid_control_characters xml.read(4*1024)
        end

        def remove_invalid_control_characters(string)
          string.gsub(/[\x00-\x08\x0b-\x0c\x0e-\x1f]/, '')
        end
      end

      class MysqlDumpDocument < Nokogiri::XML::SAX::Document
        def initialize(filters = [])
          @filters = filters
          @in_field = false
          @count_elements = 0
        end

        # The following public fields are the Nokogiri::XML::SAX::Document
        # event callbacks.

        def start_element(name, attrs = [])
          case name
          when "table_data"
            table(attrs[0][1])
          when "field"
            field_start(attrs)
          end
        end

        def end_element(name)
          case name
          when "row"
            transform_and_output_record
          when "field"
            field_end
          end
          @count_elements += 1
          print '.' if (@count_elements % 100000).zero?
          print (@count_elements/1000000).to_s if (@count_elements % 1000000).zero?
        end

        def characters(string)
          @current_field << string if @in_field
        end

        def error(string)
          $stderr.puts string
          exit 1
        end

      private

        def database
          ActiveRecord::Base.connection
        end

        def table(name)
          @record = Record.new(name)
        end

        def field_start(attrs)
          name = attrs[0][1]
          @current_field = attrs[1].nil? ? Field.new(name) : NullField.new(name)
          @in_field = true
        end

        def field_end
          @record.add(@current_field)
          @in_field = false
        end

        def transform_and_output_record
          transform
          output
        rescue StopIteration
          # do nothing
        end

        def transform
          @filters.each do |filter|
            filter.call @record
          end
        end

        def output
          if @record.table =~/ArticleCounts/i
            puts "skipping articlecounts"
            return
          end

          database.execute(@record.to_sql(database))
        rescue Mysql2::Error => e
          $stderr.puts @record.to_sql(database) + " generated #{e}"
          exit 2
        end
      end

      class Record
        attr_reader :table, :fields

        def initialize(table)
          self.table = table
          self.fields = {}
        end

        def add(field)
          fields[field.name] = field
        end
        alias_method :replace, :add

        def remove(field_name)
          fields.delete field_name
        end

        def has?(field_name)
          fields.has_key? field_name
        end

        def field(name)
          fields[name]
        end

        def to_sql(database)
          keys = fields.keys.join(',')
          values = fields.values.map {|value| value.to_sql(database) }.join(',')

          "REPLACE INTO `#{table}`(#{keys}) VALUES (#{values});"
        end

      private
        attr_writer :table, :fields
      end

      class Field
        attr_reader :name, :data

        def initialize(name, data = '')
          self.name = name
          self.data = data
        end

        def <<(input)
          data << input
        end

        def to_sql(database)
          %Q{'#{database.quote_string(data)}'}
        end

      private
        attr_writer :name, :data
      end

      class NullField < Field
        def <<(*); end

        def to_sql(database)
          'NULL'
        end
      end
    end

    module Epub6
      module ShippingRates
        class << self
          def import(rates_file_path)
            ShippingRate.destroy_all

            for_each_rate_in(rates_file_path.to_s) do |weight, rate|
              create_rate(weight, rate)
            end
          end

          private

          def create_rate(weight, rate)
            unit = weight == 1 ? 'lb' : 'lbs'
            name = "#{weight} #{unit} Shipping/Handling"

            ShippingRate.create!(shipping_rate_type: 'zone',
                                 rate: rate,
                                 display_name: name,
                                 internal_name: name,
                                 description: name,
                                 active: true,
                                 min_threshold: 0,
                                 max_threshold: 0,
                                 weight: weight,
                                 external_id: 'A',
                                 external_type: 'Ground')
          end

          def for_each_rate_in(rates_file_path)
            File.open(rates_file_path, 'r') do |f|
              f.each_line do |line|
                weight, rate = line.split(',')
                weight, rate = weight.to_i, rate.to_f

                yield(weight, rate)
              end
            end
          end
        end
      end
    end
  end
end
